[{"categories":null,"content":"TL;DR: Este artigo aborda a import√¢ncia do Graceful Shutdown nos microsservi√ßos, os sinais de desligamento (SIGTERM, SIGINT e SIGKILL) e tr√™s vis√µes sobre esse desafio: Go, Kubernetes e Istio. ","date":"01/09/2021","objectID":"/graceful-shutdown/:0:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Introdu√ß√£o A escalabilidade horizontal √© uma das principais vantagens das arquiteturas de softwares modernas para que os sistemas continuem responsivos sob varia√ß√µes de carga. Ou seja, r√©plicas dos microsservi√ßos s√£o escaladas quando a carga aumenta, e desligadas quando a carga diminui. Para que essa elasticidade (aumento e diminui√ß√£o de r√©plicas) seja natural e transparente, √© importante que o tempo de inicializa√ß√£o dos microsservi√ßos seja baixo. Quanto mais r√°pido um servi√ßo inicializar, mais r√°pido estar√° dispon√≠vel para atender requisi√ß√µes e dividir a carga com as outras r√©plicas. Pergunta E sobre o desligamento dos microsservi√ßos? O que acontece se uma r√©plica recebe um sinal para ser desligada no momento em que est√° processando requisi√ß√µes? Algumas ocasi√µes em que uma r√©plica pode receber um sinal de desligamento, s√£o: diminui√ß√£o de carga; rolling update; rolling restart. Normalmente, ao receber um sinal, o processamento dessas requisi√ß√µes seriam interrompidos e os clientes receberiam erros. A n√£o ser que esse servi√ßo tenha um processo de desligamento mais inteligente: graceful shutdown. ","date":"01/09/2021","objectID":"/graceful-shutdown/:1:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Entendendo os sinais Os sinais s√£o usados principalmente em sistemas do tipo Unix, e s√£o enviados pelo Kernel ou de algum outro programa. Os principais sinais de desligamento/encerramento de um programa, s√£o SIGTERM, SIGINT e SIGKILL. SIGTERM √© um sinal gen√©rico usado para causar o encerramento do programa. √â o sinal gerado pelo comando kill. Info O Kubernetes envia o sinal SIGTERM para matar um Pod. O sinal SIGINT √© enviado quando o usu√°rio digita CTRL-c. SIGKILL √© usado para causar o encerramento imediato do programa. N√£o pode ser interceptado ou ignorado e, portanto, √© sempre fatal. ","date":"01/09/2021","objectID":"/graceful-shutdown/:2:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Graceful shutdown Graceful Shutdown significa um desligamento inteligente, agrad√°vel, sem danos ao sistema. Para que microsservi√ßos tenham esse desligamento inteligente, eles precisam lidar com os sinais SIGTERM e SIGINT listados acima. O comportamento padr√£o da maioria das tecnologias √© interromper o processamento do programa, de forma que, muitas vezes, √© prejudicial para o funcionamento. Em Go, por exemplo, um sinal s√≠ncrono √© convertido em panic em tempo de execu√ß√£o. Uma forma simples de lidar com esses sinais, √© esperar alguns segundos para que o processamento seja finalizado. Mas pode ser necess√°rio fechar conex√µes com banco de dados, redis ou um message broker, por exemplo. O Graceful Shutdown pode ser implementado diretamente no c√≥digo do servi√ßo. Por√©m, o Kubernetes e Istio possuem configura√ß√µes que podem ajudar nessa tarefa. ","date":"01/09/2021","objectID":"/graceful-shutdown/:3:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Go A implementa√ß√£o mais comum de graceful shutdown em Go, √© usando Goroutines e Channels, como o exemplo abaixo. Dessa forma, o servidor HTTP √© inicializado numa nova goroutine, enquanto a principal espera por um sinal no channel quit. Assim que um sinal √© recebido, o servidor √© desligado com um timeout de 5 segundos. Ou seja, se em 5 segundos ainda existir alguma conex√£o ativa, a fun√ß√£o Shutdown() retorna um erro. Nota A fun√ß√£o Shutdown() foi introduzida no Go1.8 Os principais frameworks web de Go sugerem implementa√ß√µes nesse padr√£o, com Goroutines e Channels: Gin gorilla/mux echo Pra quem prefere usar bibliotecas de terceiros criadas exclusivamente para isso, eu recomendaria a ory/graceful. Foi a que mais me chamou aten√ß√£o pela simplicidade e possibilidade de customizar a fun√ß√£o de desligamento. Dica Uma adapta√ß√£o do exemplo acima utilizando a biblioteca ory/graceful, est√° dispon√≠vel no meu GitHub. ","date":"01/09/2021","objectID":"/graceful-shutdown/:4:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Kubernetes Nos Pods do Kubernetes, que representam r√©plicas de um Deployment, √© poss√≠vel configurar um hook chamado preStop, que √© invocado antes do sinal SIGTERM ser enviado. Configurando um sleep neste hook, podemos ter um graceful shutdown, como no exemplo abaixo. apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: web image: nginx ports: - name: web containerPort: 80 lifecycle: preStop: exec: command: [\"sleep\", \"15\"] O intervalo do sleep deve ser o suficiente para que a altera√ß√£o de endpoint do Kubernetes seja propagada ao kube-proxy, Ingress Controller, CoreDNS, etc. Para mais detalhes, veja esse artigo. Por padr√£o, o Kubernetes espera at√© 30 segundos no processo de desligamento de um Pod antes de for√ßar o encerramento do processo (SIGKILL, que n√£o pode ser interceptado). Dica Recomendo fortemente a leitura deste artigo para maiores detalhes sobre o Graceful Shutdown no Kubernetes. Aviso A grande desvantagem dessa abordagem √© que a imagem Docker precisa ter o comando sleep, dificultando o uso de imagens Distroless. ","date":"01/09/2021","objectID":"/graceful-shutdown/:5:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Istio O Istio possui uma configura√ß√£o chamada TerminationDrainDuration em que √© poss√≠vel definir uma pausa antes do desligamento do sidecar. Info Sidecar √© um conceito comum nas implementa√ß√µes de Service Mesh: √© um container que acompanha a aplica√ß√£o (que tamb√©m e um container) dentro do Pod do Kubernetes. Assim, temos 2 containers dentro do Pod: app + sidecar. O sidecar √© um proxy (no caso do Istio, √© o Envoy) que faz a intermedia√ß√£o de todo tr√°fego do Pod para que tenhamos todas as vantagens do Service Mesh. Quando o proxy recebe SIGTERM ou SIGINT, ele come√ßa a drenar as conex√µes, impedindo novas conex√µes e permitindo que as conex√µes existentes sejam conclu√≠das. Dica Lembrando que o SIGTERM √© enviado ap√≥s a execu√ß√£o do hook preStop A dura√ß√£o desse processo de drenagem √© configur√°vel tanto globalmente: apiVersion: install.istio.io/v1alpha1 kind: IstioOperator spec: meshConfig: defaultConfig: terminationDrainDuration: 50s quanto por workload (por Pod): annotations: proxy.istio.io/config: '{ \"terminationDrainDuration\": 50s }' A dura√ß√£o padr√£o √© 5 segundos. ","date":"01/09/2021","objectID":"/graceful-shutdown/:6:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Conclus√£o A melhor abordagem para habilitar Graceful Shutdown depende do cen√°rio de cada projeto/sistema. Existem projetos em que: alterar o c√≥digo dos microsservi√ßos √© muito trabalhoso; n√£o usa Service Mesh (Istio); o uso de imagens Distroless √© prioridade; n√£o est√£o no Kubernetes; que est√£o no Kubernetes, usando Istio, e tem agilidade para alterar o c√≥digo dos microsservi√ßos. Nesse caso √© poss√≠vel conciliar mais de uma estrat√©gia para garantir zero downtime. Pergunta Compartilhe nos coment√°rios os desafios e aprendizados do seu projeto! üòâ Qual √© o cen√°rio do seu projeto? Qual abordagem √© utilizada para graceful shutdown? Como √© a implementa√ß√£o na sua linguagem de programa√ß√£o e framework preferido? ","date":"01/09/2021","objectID":"/graceful-shutdown/:7:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Refer√™ncias Termination Signals Graceful shutdown and zero downtime deployments in Kubernetes signal package Challenges of running Istio distroless images Graceful shutdown in Go http server ","date":"01/09/2021","objectID":"/graceful-shutdown/:8:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/graceful-shutdown/"},{"categories":null,"content":"Sobre mim Ol√°, meu nome √© Matheus. Eu sou engenheiro de software na Getup, trabalhando como desenvolvedor que cria aplica√ß√µes cloud-native no projeto UnDistro. ","date":"07/08/2020","objectID":"/about/:1:0","tags":null,"title":"Sobre Matheus","uri":"/about/"},{"categories":null,"content":"Interesses Golang, Kubernetes, Cloud Native e Microsservi√ßos ","date":"07/08/2020","objectID":"/about/:2:0","tags":null,"title":"Sobre Matheus","uri":"/about/"},{"categories":null,"content":"Talks Eu gosto de compartilhar experi√™ncias e aprendizados sobre tecnologia. As minhas √∫ltimas apresenta√ß√µes p√∫blicas est√£o listadas abaixo. ","date":"07/08/2020","objectID":"/about/:3:0","tags":null,"title":"Sobre Matheus","uri":"/about/"},{"categories":null,"content":"2020 Kubernetes Operator - Meetup Golang Campinas üìÉ Slides üé• Grava√ß√£o (üáßüá∑) ","date":"07/08/2020","objectID":"/about/:3:1","tags":null,"title":"Sobre Matheus","uri":"/about/"},{"categories":null,"content":"2019 Observabilidade de Microsservi√ßos - APIX üìÉ Slides üé• Grava√ß√£o (üáßüá∑) üé• Grava√ß√£o (üá¨üáß) üé• Grava√ß√£o (üá™üá∏) Observabilidade antes e depois do Service Mesh - TDC Recife, TDC Porto Alegre e GDG Campinas üìÉ Slides üé• Grava√ß√£o (üáßüá∑) Elasticsearch - TDC Belo Horizonte e TDC Porto Alegre üìÉ Slides ","date":"07/08/2020","objectID":"/about/:3:2","tags":null,"title":"Sobre Matheus","uri":"/about/"}]