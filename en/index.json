[{"categories":null,"content":"Discover why Validating Admission Policy should standardize the policy enforcement in Kubernetes ecosystem. This article discusses benefits, motivation, and how to get started. Info This article was originally published on Undistro‚Äôs blog. ","date":"2023-06-29","objectID":"/en/validating-admission-policy/:0:0","tags":["Kubernetes"],"title":"Standardizing enforcement of security policies: Diving deep into Kubernetes Validating Admission Policy","uri":"/en/validating-admission-policy/"},{"categories":null,"content":"Introduction Kubernetes 1.26 introduced the first alpha release of validating admission policies. Validating admission policies offer a declarative, in-process alternative to validating admission webhooks. Validation rules for a policy are declared in Common Expression Language (CEL). ","date":"2023-06-29","objectID":"/en/validating-admission-policy/:1:0","tags":["Kubernetes"],"title":"Standardizing enforcement of security policies: Diving deep into Kubernetes Validating Admission Policy","uri":"/en/validating-admission-policy/"},{"categories":null,"content":"Motivation The current approach to enforcing custom policies within Kubernetes involves use of admission webhooks. It is mainly done via external admission controllers in the ecosystem such as Kyverno and OPA/Gatekeeper. Admission webhooks are HTTP callbacks that handle admission requests. There are 2 types, either validating or mutating. Mutating webhooks are able to modify objects before they are stored, whereas validating webhooks can reject requests to enforce custom policies. The diagram below shows phases of the admission control process. While admission webhooks do offer great flexibility, they come with a few drawbacks when compared to in-process policy enforcement: Additional infrastructure: required to host admission webhooks. Latency: requires another network hop. Less reliable: due to extra infrastructure dependencies. \"Failing closed or failing open\" dilemma: reduce the cluster availability or limit the efficacy of policy enforcement? Operationally burdensome: observability, security, and proper release/rollout/rollback plans. ","date":"2023-06-29","objectID":"/en/validating-admission-policy/:2:0","tags":["Kubernetes"],"title":"Standardizing enforcement of security policies: Diving deep into Kubernetes Validating Admission Policy","uri":"/en/validating-admission-policy/"},{"categories":null,"content":"Getting started with Validating Admission Policies Let‚Äôs see how validating admission policies work. Since this feature is in alpha stage, the feature gate ValidatingAdmissionPolicy should be enabled. We can create a Kubernetes cluster with Kind providing a configuration file that enables the feature gate. kind create cluster --config kind-config.yaml The content of kind-config.yaml file: kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 featureGates: \"ValidatingAdmissionPolicy\": true runtimeConfig: \"admissionregistration.k8s.io/v1alpha1\": \"true\" nodes: - role: control-plane image: kindest/node:v1.27.2 The following command checks if the API is enabled: kubectl api-resources | grep validating validatingadmissionpolicies admissionregistration.k8s.io/v1alpha1 false ValidatingAdmissionPolicy validatingadmissionpolicybindings admissionregistration.k8s.io/v1alpha1 false ValidatingAdmissionPolicyBinding validatingwebhookconfigurations admissionregistration.k8s.io/v1 false ValidatingWebhookConfiguration Once the ValidatingAdmissionPolicy is enabled, we are able to create our policies with CEL expressions. Let‚Äôs create a policy that enforces a tag different from latest in Pod images. A policy is made up of at least two resources: The ValidatingAdmissionPolicy describes the logic of a policy. A ValidatingAdmissionPolicyBinding links the above resources together and provides scoping. Here is our policy. The description of the most important fields are listed as comments, take a look. apiVersion: admissionregistration.k8s.io/v1alpha1 kind: ValidatingAdmissionPolicy metadata: name: image-tag-latest spec: failurePolicy: Fail # if an expression evaluates to false, the validation check is enforced according to this field matchConstraints: resourceRules: - apiGroups: [\"\"] apiVersions: [\"v1\"] operations: [\"CREATE\", \"UPDATE\"] resources: [\"pods\"] validations: # the field below contains a CEL expression to validate the request - expression: | object.spec.containers.all(container, container.image.contains(\":\") \u0026\u0026 [container.image.substring(container.image.lastIndexOf(\":\")+1)].all(image, !image.contains(\"/\") \u0026\u0026 !(image in [\"latest\", \"\"]) ) ) message: \"Image tag 'latest' is not allowed. Use a tag from a specific version.\" --- apiVersion: admissionregistration.k8s.io/v1alpha1 kind: ValidatingAdmissionPolicyBinding metadata: name: image-tag-latest spec: policyName: image-tag-latest # references a `ValidatingAdmissionPolicy` name validationActions: [Deny] # `Deny` specifies that a validation failure results in a denied request matchResources: {} # an empty `matchResources` means that all resources matched by the policy are validated by this binding Now we can apply the policy: kubectl apply -f vap.yaml If you try to create a Pod with an untagged image, an error will return with the message we defined: kubectl apply -f pod.yaml The pods \"nginx\" is invalid: : ValidatingAdmissionPolicy 'image-tag-latest' with binding 'image-tag-latest' denied request: Image tag 'latest' is not allowed. Use a tag from a specific version. The content of pod.yaml file is below. apiVersion: v1 kind: Pod metadata: name: nginx labels: app: nginx spec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent restartPolicy: Always Different values can be substituted in the image field to test different cases: Image Expect nginx@sha256:af296b188c7b7df99ba960ca614439c99cb7cf252ed7bbc23e90cfda59092305 pass nginx:1.25.0 pass nginx:latest fail nginx fail ","date":"2023-06-29","objectID":"/en/validating-admission-policy/:3:0","tags":["Kubernetes"],"title":"Standardizing enforcement of security policies: Diving deep into Kubernetes Validating Admission Policy","uri":"/en/validating-admission-policy/"},{"categories":null,"content":"Comparing policies See how the same policy is defined in external admission controllers. Validating Admission Policy: apiVersion: admissionregistration.k8s.io/v1alpha1 kind: ValidatingAdmissionPolicy metadata: name: image-tag-latest spec: failurePolicy: Fail # if an expression evaluates to false, the validation check is enforced according to this field matchConstraints: resourceRules: - apiGroups: [\"\"] apiVersions: [\"v1\"] operations: [\"CREATE\", \"UPDATE\"] resources: [\"pods\"] validations: # the field below contains a CEL expression to validate the request - expression: | object.spec.containers.all(container, container.image.contains(\":\") \u0026\u0026 [container.image.substring(container.image.lastIndexOf(\":\")+1)].all(image, !image.contains(\"/\") \u0026\u0026 !(image in [\"latest\", \"\"]) ) ) message: \"Image tag 'latest' is not allowed. Use a tag from a specific version.\" OPA/Gatekeeper: apiVersion: templates.gatekeeper.sh/v1 kind: ConstraintTemplate metadata: name: k8sdisallowedtags spec: crd: spec: names: kind: K8sDisallowedTags validation: openAPIV3Schema: type: object properties: tags: type: array description: Disallowed container image tags. items: type: string targets: - target: admission.k8s.gatekeeper.sh rego: | package k8sdisallowedtags violation[{\"msg\": msg}] { container := input_containers[_] tags := [forbid | tag = input.parameters.tags[_] ; forbid = endswith(container.image, concat(\":\", [\"\", tag]))] any(tags) msg := sprintf(\"container \u003c%v\u003e uses a disallowed tag \u003c%v\u003e; disallowed tags are %v\", [container.name, container.image, input.parameters.tags]) } violation[{\"msg\": msg}] { container := input_containers[_] tag := [contains(container.image, \":\")] not all(tag) msg := sprintf(\"container \u003c%v\u003e didn't specify an image tag \u003c%v\u003e\", [container.name, container.image]) } input_containers[c] { c := input.review.object.spec.containers[_] } input_containers[c] { c := input.review.object.spec.initContainers[_] } input_containers[c] { c := input.review.object.spec.ephemeralContainers[_] } --- apiVersion: constraints.gatekeeper.sh/v1beta1 kind: K8sDisallowedTags metadata: name: container-image-must-not-have-latest-tag spec: match: kinds: - apiGroups: [\"\"] kinds: [\"Pod\"] namespaces: - \"default\" parameters: tags: [\"latest\"] Kyverno: apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: disallow-latest-tag spec: validationFailureAction: audit background: true rules: - name: require-image-tag match: any: - resources: kinds: - Pod validate: message: \"An image tag is required.\" pattern: spec: containers: - image: \"*:*\" - name: validate-image-tag match: any: - resources: kinds: - Pod validate: message: \"Using a mutable image tag e.g. 'latest' is not allowed.\" pattern: spec: containers: - image: \"!*:latest\" Kyverno with CEL (new): Kyverno recently has added support for CEL expressions. See the PR. This is a very recent feature, and the API is subject to change. As of this post‚Äôs writing, this feature has not yet been documented. apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: disallow-latest-tag spec: validationFailureAction: Enforce background: false rules: - name: image-tag match: any: - resources: kinds: - Pod validate: cel: expressions: - expression: | object.spec.containers.all(container, ( container.image.contains(\":\") || container.image.contains(\"@\") ) \u0026\u0026 !container.image.endsWith(\":latest\") ) message: \"Image tag 'latest' is not allowed. Use a tag from a specific version.\" ","date":"2023-06-29","objectID":"/en/validating-admission-policy/:4:0","tags":["Kubernetes"],"title":"Standardizing enforcement of security policies: Diving deep into Kubernetes Validating Admission Policy","uri":"/en/validating-admission-policy/"},{"categories":null,"content":"Conclusion Looking at the Kubernetes ecosystem as a whole, it is evident that there‚Äôs a demand for opinionated policy frameworks. The existence of security regimes such as CIS Kubernetes Benchmarks emphasizes the importance of standardized controls. Validating Admission Policy is a policy enforcement feature that fulfills a community need and should be the best alternative for the vast majority of validations due to reduced infrastructure footprint and the simplicity of CEL. In-process admission control has fundamental advantages over webhooks: it is far safer to use in a ‚Äúfail closed‚Äù mode because it removes the network as a possible failure domain. According to the KEP (Kubernetes Enhancement Proposal) of this feature, it‚Äôs not a goal currently to support mutations and to build an in-tree policy framework. Therefore, projects in the ecosystem should not be completely replaced when this feature is graduated. Instead, they should make use of these APIs‚Äô extensibility and configurability. One of the goals is to provide core functionality as a library and enable other tools to run the same CEL validation checks that the API server does. This should popularize the use of CEL for policies and checks in the Kubernetes ecosystem. Even though still in alpha stage, we can already observe the impact of Validating Admission Policy: Kyverno is developing a feature which supports CEL expressions in validations, as can be seen in the comparing policies section. We should expect to see new projects emerging that use CEL in use cases beyond admissions control. One great example is Marvin, a CLI tool that scans Kubernetes clusters by performing CEL expressions to report potential issues. Marvin has 30+ built-in checks and also supports custom checks with CEL, allowing you to use virtually the same expression in both cases: Kubernetes ValidatingAdmissionPolicy (policy enforcement) and Marvin (cluster scanner). ","date":"2023-06-29","objectID":"/en/validating-admission-policy/:5:0","tags":["Kubernetes"],"title":"Standardizing enforcement of security policies: Diving deep into Kubernetes Validating Admission Policy","uri":"/en/validating-admission-policy/"},{"categories":null,"content":"References https://kubernetes.io/docs/reference/access-authn-authz/validating-admission-policy https://kubernetes.io/blog/2022/12/20/validating-admission-policies-alpha https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/3488-cel-admission-control/README.md https://github.com/undistro/marvin ","date":"2023-06-29","objectID":"/en/validating-admission-policy/:6:0","tags":["Kubernetes"],"title":"Standardizing enforcement of security policies: Diving deep into Kubernetes Validating Admission Policy","uri":"/en/validating-admission-policy/"},{"categories":null,"content":"TL;DR: This article discusses the importance of Graceful Shutdown in microservices, the shutdown signals (SIGTERM, SIGINT and SIGKILL) and three perspectives on this challenge: Go, Kubernetes, and Istio. ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:0:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"Introduction Horizontal scalability is one of the key advantages of modern software architectures to ensure systems remain responsive under varying loads. In other words, replicas of microservices are scaled up when the load increases and scaled down when the load decreases. For this elasticity (increase and decrease of replicas) to be seamless and transparent, it is important for the initialization time of microservices to be low. The faster a service initializes, the quicker it becomes available to handle requests and share the load with other replicas. Question What about the shutdown of microservices? What happens if a replica receives a shutdown signal while it‚Äôs processing requests? Some situations where a replica may receive a shutdown signal include: load decrease rolling update rolling restart Normally, upon receiving a signal, the processing of these requests would be interrupted, and clients would receive errors. Unless the service has a smarter shutdown process: graceful shutdown. ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:1:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"Understanding the signals Signals are primarily used in Unix-like systems and are sent by the kernel or some other program. The main shutdown/termination signals for a program are SIGTERM, SIGINT and SIGKILL. SIGTERM is a generic signal used to cause program termination. It is the signal generated by the kill command. Info Kubernetes sends the SIGTERM signal to kill a Pod. The SIGINT signal is sent when the user types CTRL-c. SIGKILL is used to immediately terminate a program. It cannot be intercepted or ignored and is thus always fatal. ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:2:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"Graceful shutdown Graceful shutdown refers to a controlled and seamless termination process that avoids system harm. To enable graceful shutdown, microservices should effectively handle the SIGTERM and SIGINT signals mentioned above. The default behavior of most technologies is to abruptly stop program processing, which often negatively impacts functionality. For example, in Go, a synchronous signal is converted into a runtime panic. A simple way to handle these signals is to wait a few seconds for processing to complete. However, it may be necessary to close connections to databases, Redis, or a message broker, for example. Graceful shutdown can be implemented directly in the service‚Äôs code. However, Kubernetes and Istio have configurations that can help in this task. ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:3:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"Go The most common implementation of graceful shutdown in Go is using Goroutines and Channels, as shown in the example below. In this example, the HTTP server is initialized in a new Goroutine while the main Goroutine waits for a signal on the quit channel. Once a signal is received, the server is shut down with a timeout of 5 seconds. If there are still active connections after 5 seconds, the Shutdown() function returns an error. Note The Shutdown() function was introduced in Go1.8 The main web frameworks in Go suggest implementations following this pattern with Goroutines and Channels: Gin gorilla/mux echo For those who prefer to use third-party libraries specifically created for this purpose, I would recommend ory/graceful. Tip An adaptation of the above example using the ory/graceful library is available on my GitHub. ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:4:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"Kubernetes In Kubernetes Pods, it is possible to configure a hook called preStop, which is invoked before the SIGTERM signal is sent. By setting a sleep command in this hook, we can achieve graceful shutdown, as shown in the example below. apiVersion: v1 kind: Pod metadata: name: my-pod spec: containers: - name: web image: nginx ports: - name: web containerPort: 80 lifecycle: preStop: exec: command: [\"sleep\", \"15\"] The sleep interval should be sufficient for the Kubernetes endpoint change to propagate to kube-proxy, Ingress Controller, CoreDNS, etc. For more details, refer to this article. By default, Kubernetes waits for up to 30 seconds during the Pod shutdown process before forcefully terminating the process (SIGKILL, which cannot be intercepted). Tip I strongly recommend reading this article for more details on Graceful Shutdown in Kubernetes. Warning The main disadvantage of this approach is that the Docker image needs to have the sleep command, making it difficult to use Distroless images. ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:5:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"Istio Istio has the configuration TerminationDrainDuration, which allows defining a pause before shutting down the sidecar. Info Sidecar is a common concept in Service Mesh implementations. It is a container that accompanies the application (which is also a container) within the Kubernetes Pod. Thus, we have 2 containers inside the Pod: app + sidecar. The sidecar is a proxy (in the case of Istio, it is Envoy) that intermediates all Pod traffic, providing all the advantages of the Service Mesh. When the proxy receives SIGTERM or SIGINT, it starts draining connections, preventing new connections and allowing existing connections to complete. Tip Remember that SIGTERM is sent after the execution of the preStop hook. The duration of this draining process is configurable both globally: apiVersion: install.istio.io/v1alpha1 kind: IstioOperator spec: meshConfig: defaultConfig: terminationDrainDuration: 50s and per workload: annotations: proxy.istio.io/config: '{ \"terminationDrainDuration\": 50s }' The default duration is 5 seconds. ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:6:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"Conclusion The best approach to enable Graceful Shutdown depends on the scenario of each project/system. There are projects where: modifying the microservices‚Äô code is very laborious; Service Mesh is not used; the use of Distroless images is a priority; they are not running on Kubernetes; they are running on Kubernetes, using Istio, and have the agility to modify the microservices‚Äô code. In this case, it is possible to combine multiple strategies to ensure zero downtime. Question Share in the comments the challenges and lessons learned from your project! üòâ What is the scenario of your project? What approach is used for graceful shutdown? How is the implementation in your preferred programming language and framework? ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:7:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"References Termination Signals Graceful shutdown and zero downtime deployments in Kubernetes signal package Challenges of running Istio distroless images Graceful shutdown in Go http server ","date":"2021-09-01","objectID":"/en/graceful-shutdown/:8:0","tags":["Go","Kubernetes","Istio"],"title":"Graceful Shutdown","uri":"/en/graceful-shutdown/"},{"categories":null,"content":"About me Hi, my name is Matheus. I‚Äôm a software engineer at Getup, working as developer who creates cloud-native apps on the UnDistro project. ","date":"2020-08-07","objectID":"/en/about/:1:0","tags":null,"title":"About Matheus","uri":"/en/about/"},{"categories":null,"content":"Interests Golang, Kubernetes, Cloud Native and Microservices ","date":"2020-08-07","objectID":"/en/about/:2:0","tags":null,"title":"About Matheus","uri":"/en/about/"},{"categories":null,"content":"Talks I like to share my experiences and learnings about technology. My latest public talks are listed below. ","date":"2020-08-07","objectID":"/en/about/:3:0","tags":null,"title":"About Matheus","uri":"/en/about/"},{"categories":null,"content":"2020 Kubernetes Operator - Meetup Golang Campinas üìÉ Slides üé• Recording (üáßüá∑) ","date":"2020-08-07","objectID":"/en/about/:3:1","tags":null,"title":"About Matheus","uri":"/en/about/"},{"categories":null,"content":"2019 Microservices Observability - APIX üìÉ Slides üé• Recording (üáßüá∑) üé• Recording (üá¨üáß) üé• Recording (üá™üá∏) Observability before and after the Service Mesh - TDC Recife, TDC Porto Alegre and GDG Campinas üìÉ Slides üé• Recording (üáßüá∑) Elasticsearch - TDC Belo Horizonte and TDC Porto Alegre üìÉ Slides ","date":"2020-08-07","objectID":"/en/about/:3:2","tags":null,"title":"About Matheus","uri":"/en/about/"}]